{"version":3,"file":"index.js","sources":["../src/Peer.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nconst defaultMaxChannelMessageSize = 16384;\n\nexport interface PeerOptions {\n  id?: string;\n  trickle?: boolean;\n  sdpTransform?: (sdp?: string) => string;\n  channelName?: string;\n  channelConfig?: RTCDataChannelInit;\n  config?: RTCConfiguration;\n  offerConfig?: RTCOfferOptions;\n  answerConfig?: RTCAnswerOptions;\n  maxChannelMessageSize?: number;\n  webrtc?: PeerWebRTC;\n}\n\nexport interface PeerWebRTC {\n  RTCPeerConnection: typeof RTCPeerConnection;\n  RTCSessionDescription: typeof RTCSessionDescription;\n  RTCIceCandidate: typeof RTCIceCandidate;\n}\n\nconst DEFAULT_WEBRTC: PeerWebRTC = {\n  RTCPeerConnection:\n    typeof RTCPeerConnection === \"undefined\"\n      ? (null as never)\n      : (RTCPeerConnection as never),\n  RTCSessionDescription:\n    typeof RTCSessionDescription === \"undefined\"\n      ? (null as never)\n      : (RTCSessionDescription as never),\n  RTCIceCandidate:\n    typeof RTCIceCandidate === \"undefined\"\n      ? (null as never)\n      : (RTCIceCandidate as never),\n};\n\ninterface PeerEvents {\n  signal(message: never): void;\n  connect(): void;\n  data(event: string | Blob | ArrayBuffer | Uint8Array): void;\n  error(error: Error): void;\n  close(): void;\n  transceiver(transceiver: RTCRtpTransceiver): void;\n  track(track: RTCTrackEvent): void;\n}\n\ntype PeerEventNames = EventEmitterTypes.EventNames<PeerEvents>;\ntype PeerEventArguments = EventEmitterTypes.ArgumentMap<PeerEvents>;\ntype EventEmitterReturnType<T> = T extends []\n  ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n    void\n  : T extends [infer R]\n  ? R\n  : T;\n\nexport class Peer extends EventEmitter<PeerEvents> {\n  private id: string;\n  private initiator = false;\n  private channelName: string;\n  private channelConfig?: RTCDataChannelInit;\n  private channel?: RTCDataChannel;\n  private maxChannelMessageSize = defaultMaxChannelMessageSize;\n  private trickle = true;\n  private sdpTransform = sdpTransform;\n  private config: RTCConfiguration = { iceServers: [] };\n  private connection?: RTCPeerConnection;\n  private offerConfig?: RTCOfferOptions;\n  private answerConfig?: RTCAnswerOptions;\n  private pendingCandidates: RTCIceCandidateInit[] = [];\n  private webrtc: PeerWebRTC = DEFAULT_WEBRTC;\n\n  constructor(options: PeerOptions) {\n    super();\n    this.id = options.id || uuidv4();\n    this.channelName = options.channelName || uuidv4();\n    if (options.channelConfig) {\n      this.channelConfig = options.channelConfig;\n    }\n    if (options.trickle === false) {\n      this.trickle = false;\n    }\n    if (options.sdpTransform) {\n      this.sdpTransform = options.sdpTransform;\n    }\n    if (options.config) {\n      this.config = options.config;\n    }\n    if (options.offerConfig) {\n      this.offerConfig = options.offerConfig;\n    }\n    if (options.answerConfig) {\n      this.answerConfig = options.answerConfig;\n    }\n    if (options.maxChannelMessageSize && options.maxChannelMessageSize > 0) {\n      this.maxChannelMessageSize = options.maxChannelMessageSize;\n    }\n    if (options.webrtc) {\n      this.webrtc = options.webrtc;\n    }\n  }\n\n  getId() {\n    return this.id;\n  }\n\n  getConnection() {\n    return this.connection;\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  isReady() {\n    return this.channel && this.channel.readyState === \"open\";\n  }\n\n  isClosed() {\n    return !this.connection || this.connection.connectionState !== \"connected\";\n  }\n\n  ready(): Promise<void> {\n    if (this.isReady()) {\n      return Promise.resolve();\n    }\n    return this.waitOnce(\"connect\");\n  }\n\n  isInitiator() {\n    return this.initiator;\n  }\n\n  init() {\n    this.initiator = true;\n    this.createPeer();\n    return this.needsNegotiation();\n  }\n\n  close() {\n    return this.internalClose(true);\n  }\n\n  send(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    this.channel.send(chunk as never);\n    return this;\n  }\n\n  write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return write(this.channel, chunk, this.maxChannelMessageSize);\n  }\n\n  writableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return writableStreamFromChannel(this.channel, this.maxChannelMessageSize);\n  }\n\n  readableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return readableStreamFromChannel(this.channel);\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  async signal(message: any) {\n    if (!this.connection) {\n      await this.createPeer();\n    }\n\n    console.debug(`${this.id}: received signal message=${message.type}`);\n    switch (message.type) {\n      case \"renegotiate\": {\n        return this.needsNegotiation();\n      }\n      case \"transceiverRequest\": {\n        if (!this.initiator) {\n          throw new Error(\"Invalid signal state\");\n        }\n        const transceiverRequest = message.transceiverRequest;\n        if (!transceiverRequest) {\n          throw new Error(\"Invalid signal message\");\n        }\n        await this.addTransceiverFromKind(\n          transceiverRequest.kind,\n          transceiverRequest.init\n        );\n        return this;\n      }\n      case \"candidate\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const candidateJSON = message.candidate;\n        if (!candidateJSON) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const candidate = new this.webrtc.RTCIceCandidate(candidateJSON);\n        if (this.connection.remoteDescription == null) {\n          this.pendingCandidates.push(candidate);\n        } else {\n          await this.connection.addIceCandidate(candidate);\n        }\n        return this;\n      }\n      case \"answer\":\n      case \"offer\":\n      case \"pranswer\":\n      case \"rollback\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const sdp = message.sdp;\n        if (!sdp) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const sessionDescription = new this.webrtc.RTCSessionDescription({\n          type: message.type,\n          sdp,\n        });\n        console.debug(`${this.id}: setting remote sdp`);\n        await this.connection.setRemoteDescription(sessionDescription);\n        for (const candidate of this.pendingCandidates) {\n          await this.connection.addIceCandidate(candidate);\n        }\n        this.pendingCandidates.length = 0;\n        if (this.connection?.remoteDescription?.type === \"offer\") {\n          await this.createAnswer();\n        }\n        return this;\n      }\n      default: {\n        console.debug(`${this.id}: invalid signal type: ${message}`);\n        throw new Error(\"Invalid signal message type\");\n      }\n    }\n  }\n\n  waitOnce<K extends PeerEventNames>(event: K) {\n    return new Promise<EventEmitterReturnType<PeerEventArguments[K]>>(\n      (resolve) => {\n        this.once(event, (...args) => {\n          switch (args.length) {\n            case 0:\n              resolve(undefined as never);\n              break;\n            case 1:\n              resolve(args[0]);\n              break;\n            default:\n              resolve(args as never);\n              break;\n          }\n        });\n      }\n    );\n  }\n\n  addTransceiverFromKind(kind: string, init?: RTCRtpTransceiverInit) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      const transceiver = this.connection.addTransceiver(kind, init);\n      this.emit(\"transceiver\", transceiver);\n      this.needsNegotiation();\n      return transceiver;\n    }\n    this.internalSignal({\n      type: \"transceiverRequest\",\n      transceiverRequest: {\n        kind,\n        init,\n      },\n    });\n    return null;\n  }\n\n  addTrack(track: MediaStreamTrack) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    const sender = this.connection.addTrack(track);\n    this.needsNegotiation();\n    return sender;\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    this.connection.removeTrack(sender);\n    this.needsNegotiation();\n    return this;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private internalSignal(message: any) {\n    this.emit(\"signal\", message);\n    return this;\n  }\n\n  private runningNegotiation = false;\n  private async needsNegotiation() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    if (this.initiator) {\n      if (!this.runningNegotiation) {\n        try {\n          this.runningNegotiation = true;\n          await asap();\n          await this.negotiate();\n        } finally {\n          this.runningNegotiation = false;\n        }\n      }\n    }\n    return this;\n  }\n\n  private async negotiate() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      await waitMS(0);\n      await this.createOffer();\n    } else {\n      this.internalSignal({ type: \"renegotiate\", renegotiate: true });\n    }\n    return this;\n  }\n\n  private async createOffer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const offer = await this.connection.createOffer(this.offerConfig);\n    if (!this.trickle) {\n      offer.sdp = filterTrickle(offer.sdp);\n    }\n    offer.sdp = this.sdpTransform(offer.sdp);\n    await this.connection.setLocalDescription(offer);\n    this.internalSignal({ type: offer.type, sdp: offer.sdp });\n    return this;\n  }\n\n  private async createAnswer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const answer = await this.connection.createAnswer(this.answerConfig);\n    if (!this.trickle) {\n      answer.sdp = filterTrickle(answer.sdp);\n    }\n    answer.sdp = this.sdpTransform(answer.sdp);\n    await this.connection.setLocalDescription(answer);\n    this.internalSignal({ type: answer.type, sdp: answer.sdp });\n    return this;\n  }\n\n  private createPeer() {\n    this.internalClose(false);\n\n    this.connection = new this.webrtc.RTCPeerConnection(this.config);\n    this.connection.addEventListener(\n      \"connectionstatechange\",\n      this.onConnectionStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"icecandidate\",\n      this.onICECandidate.bind(this)\n    );\n    this.connection.addEventListener(\"track\", this.onTrackRemote.bind(this));\n\n    if (this.initiator) {\n      const channel = this.connection.createDataChannel(\n        this.channelName,\n        this.channelConfig\n      );\n      channel.addEventListener(\"open\", this.onDataChannelOpen.bind(this));\n      channel.addEventListener(\"message\", this.onDataChannelMessage.bind(this));\n      channel.addEventListener(\"error\", this.onDataChannelError.bind(this));\n      this.channel = channel;\n    } else {\n      this.connection.addEventListener(\n        \"datachannel\",\n        this.onDataChannel.bind(this)\n      );\n    }\n    return this;\n  }\n\n  private internalClose(triggerCallbacks = true) {\n    if (this.channel) {\n      this.channel.close();\n      this.channel = undefined;\n    }\n\n    if (this.connection) {\n      this.connection.close();\n      this.connection = undefined;\n    }\n\n    if (triggerCallbacks) {\n      this.emit(\"close\");\n    }\n    return this;\n  }\n\n  private onConnectionStateChange() {\n    if (!this.connection) return;\n\n    switch (this.connection.connectionState) {\n      case \"connected\":\n        break;\n      case \"failed\":\n      case \"disconnected\":\n      case \"closed\":\n        this.internalClose(true);\n        break;\n    }\n  }\n\n  private onICECandidate(event: RTCPeerConnectionIceEvent) {\n    if (event.candidate) {\n      this.internalSignal({\n        type: \"candidate\",\n        candidate: event.candidate,\n      });\n    }\n  }\n\n  private onTrackRemote(event: RTCTrackEvent) {\n    this.emit(\"track\", event);\n  }\n\n  private onDataChannel(event: RTCDataChannelEvent) {\n    const channel = event.channel;\n    this.channel = channel;\n    this.channel.onopen = this.onDataChannelOpen.bind(this);\n    this.channel.onmessage = this.onDataChannelMessage.bind(this);\n    this.channel.onerror = this.onDataChannelError.bind(this);\n  }\n\n  private onDataChannelOpen() {\n    console.debug(`${this.id}: data channel open`);\n    this.emit(\"connect\");\n  }\n\n  private onDataChannelMessage(\n    event: MessageEvent<string | Blob | ArrayBuffer | Uint8Array>\n  ) {\n    this.emit(\"data\", event.data);\n  }\n\n  private onDataChannelError(event: Event) {\n    this.emit(\"error\", new Error(\"DataChannel error\", { cause: event }));\n  }\n}\n\nfunction filterTrickle(sdp?: string) {\n  return sdp?.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction sdpTransform(sdp?: string) {\n  return sdp;\n}\nfunction asap() {\n  return new Promise<void>((resolve) => resolve());\n}\nfunction waitMS(ms: number) {\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction write(\n  channel: RTCDataChannel,\n  chunk: string | Blob | ArrayBuffer | ArrayBufferView,\n  maxChannelMessageSize: number\n) {\n  if (typeof chunk === \"string\") {\n    if (chunk.length < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.length) {\n        const length = Math.min(maxChannelMessageSize, chunk.length - offset);\n        channel.send(chunk.substring(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else if (chunk instanceof Blob) {\n    if (chunk.size < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.size) {\n        const length = Math.min(maxChannelMessageSize, chunk.size - offset);\n        channel.send(chunk.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else {\n    let buffer: ArrayBuffer;\n    if (chunk instanceof ArrayBuffer) {\n      buffer = chunk;\n    } else {\n      buffer = chunk.buffer;\n    }\n    if (buffer.byteLength < maxChannelMessageSize) {\n      channel.send(buffer);\n    } else {\n      let offset = 0;\n      while (offset < buffer.byteLength) {\n        const length = Math.min(\n          maxChannelMessageSize,\n          buffer.byteLength - offset\n        );\n        channel.send(buffer.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  }\n}\n\nexport function writableStreamFromChannel(\n  channel: RTCDataChannel,\n  maxChannelMessageSize: number\n) {\n  return new WritableStream({\n    write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n      write(channel, chunk, maxChannelMessageSize);\n    },\n  });\n}\n\nexport function readableStreamFromChannel(channel: RTCDataChannel) {\n  let closed = false;\n  let closedController = false;\n  const queue: Array<string | Blob | ArrayBuffer> = [];\n  const pullQueue: Array<\n    [\n      resolve: (data: string | Blob | ArrayBuffer) => void,\n      reject: (error?: Error) => void\n    ]\n  > = [];\n  function pull() {\n    return new Promise<string | Blob | ArrayBuffer>((resolve, reject) =>\n      pullQueue.push([resolve, reject])\n    );\n  }\n  function onMessage(event: MessageEvent<string | Blob | ArrayBuffer>) {\n    if (pullQueue.length) {\n      // biome-ignore lint/style/noNonNullAssertion: checked above\n      const [resolve, _reject] = pullQueue.shift()!;\n      resolve(event.data);\n    } else {\n      queue.push(event.data);\n    }\n  }\n  channel.addEventListener(\"message\", onMessage);\n  const onClose = () => {\n    if (closed) {\n      return;\n    }\n    channel.removeEventListener(\"message\", onMessage);\n    channel.removeEventListener(\"close\", onClose);\n    closed = true;\n    for (const [_resolve, reject] of pullQueue) {\n      reject(new Error(\"Stream closed\"));\n    }\n    pullQueue.length = 0;\n    queue.length = 0;\n  };\n  channel.addEventListener(\"close\", onClose);\n  return new ReadableStream<string | Blob | ArrayBuffer>({\n    async pull(controller) {\n      if (closed) {\n        if (!closedController) {\n          closedController = true;\n          controller.close();\n        }\n        return;\n      }\n      if (queue.length) {\n        controller.enqueue(queue.shift());\n      } else {\n        controller.enqueue(await pull());\n      }\n    },\n    cancel: onClose,\n  });\n}\n"],"names":["DEFAULT_WEBRTC","RTCPeerConnection","RTCSessionDescription","RTCIceCandidate","Peer","EventEmitter","constructor","options","super","this","initiator","maxChannelMessageSize","trickle","sdpTransform","config","iceServers","pendingCandidates","webrtc","runningNegotiation","id","uuidv4","channelName","channelConfig","offerConfig","answerConfig","getId","getConnection","connection","getChannel","channel","isReady","readyState","isClosed","connectionState","ready","Promise","resolve","waitOnce","isInitiator","init","createPeer","needsNegotiation","close","internalClose","send","chunk","Error","write","writableStream","writableStreamFromChannel","readableStream","readableStreamFromChannel","signal","message","console","debug","type","transceiverRequest","addTransceiverFromKind","kind","candidateJSON","candidate","remoteDescription","push","addIceCandidate","sdp","sessionDescription","setRemoteDescription","length","_b","_a","createAnswer","event","once","args","undefined","transceiver","addTransceiver","emit","internalSignal","addTrack","track","sender","removeTrack","negotiate","ms","setTimeout","createOffer","renegotiate","offer","filterTrickle","setLocalDescription","answer","addEventListener","onConnectionStateChange","bind","onICECandidate","onTrackRemote","createDataChannel","onDataChannelOpen","onDataChannelMessage","onDataChannelError","onDataChannel","triggerCallbacks","onopen","onmessage","onerror","data","cause","replace","offset","Math","min","substring","Blob","size","slice","buffer","ArrayBuffer","byteLength","WritableStream","closed","closedController","queue","pullQueue","onMessage","_reject","shift","onClose","removeEventListener","_resolve","reject","ReadableStream","pull","controller","enqueue","cancel"],"mappings":"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"}
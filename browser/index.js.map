{"version":3,"file":"index.js","sources":["../src/Peer.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport {\n\tEventEmitter,\n\ttype EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nconst defaultMaxChannelMessageSize = 16384;\n\nexport interface PeerOptions {\n\tid?: string;\n\ttrickle?: boolean;\n\tsdpTransform?: (sdp?: string) => string;\n\tchannelName?: string;\n\tchannelConfig?: RTCDataChannelInit;\n\tconfig?: RTCConfiguration;\n\tofferConfig?: RTCOfferOptions;\n\tanswerConfig?: RTCAnswerOptions;\n\tmaxChannelMessageSize?: number;\n\twebrtc?: PeerWebRTC;\n}\n\nexport interface PeerWebRTC {\n\tRTCPeerConnection: typeof RTCPeerConnection;\n\tRTCSessionDescription: typeof RTCSessionDescription;\n\tRTCIceCandidate: typeof RTCIceCandidate;\n}\n\nconst DEFAULT_WEBRTC: PeerWebRTC = {\n\tRTCPeerConnection:\n\t\ttypeof RTCPeerConnection === \"undefined\"\n\t\t\t? (null as never)\n\t\t\t: (RTCPeerConnection as never),\n\tRTCSessionDescription:\n\t\ttypeof RTCSessionDescription === \"undefined\"\n\t\t\t? (null as never)\n\t\t\t: (RTCSessionDescription as never),\n\tRTCIceCandidate:\n\t\ttypeof RTCIceCandidate === \"undefined\"\n\t\t\t? (null as never)\n\t\t\t: (RTCIceCandidate as never),\n};\n\ninterface PeerEvents {\n\tsignal(message: never): void;\n\tconnect(): void;\n\tdata(event: string | Blob | ArrayBuffer | Uint8Array): void;\n\terror(error: Error): void;\n\tclose(): void;\n\ttransceiver(transceiver: RTCRtpTransceiver): void;\n\ttrack(track: RTCTrackEvent): void;\n\tnegotiated(): void;\n}\n\ntype PeerEventNames = EventEmitterTypes.EventNames<PeerEvents>;\ntype PeerEventArguments = EventEmitterTypes.ArgumentMap<PeerEvents>;\ntype EventEmitterReturnType<T> = T extends []\n\t? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n\t\tvoid\n\t: T extends [infer R]\n\t\t? R\n\t\t: T;\n\nexport class Peer extends EventEmitter<PeerEvents> {\n\tprivate id: string;\n\tprivate initiator = false;\n\tprivate channelName: string;\n\tprivate channelConfig?: RTCDataChannelInit;\n\tprivate channel?: RTCDataChannel;\n\tprivate maxChannelMessageSize = defaultMaxChannelMessageSize;\n\tprivate trickle = true;\n\tprivate sdpTransform = sdpTransform;\n\tprivate config: RTCConfiguration = { iceServers: [] };\n\tprivate connection?: RTCPeerConnection;\n\tprivate offerConfig?: RTCOfferOptions;\n\tprivate answerConfig?: RTCAnswerOptions;\n\tprivate pendingCandidates: RTCIceCandidateInit[] = [];\n\tprivate webrtc: PeerWebRTC = DEFAULT_WEBRTC;\n\n\tconstructor(options: PeerOptions) {\n\t\tsuper();\n\t\tthis.id = options.id || uuidv4();\n\t\tthis.channelName = options.channelName || uuidv4();\n\t\tif (options.channelConfig) {\n\t\t\tthis.channelConfig = options.channelConfig;\n\t\t}\n\t\tif (options.trickle === false) {\n\t\t\tthis.trickle = false;\n\t\t}\n\t\tif (options.sdpTransform) {\n\t\t\tthis.sdpTransform = options.sdpTransform;\n\t\t}\n\t\tif (options.config) {\n\t\t\tthis.config = options.config;\n\t\t}\n\t\tif (options.offerConfig) {\n\t\t\tthis.offerConfig = options.offerConfig;\n\t\t}\n\t\tif (options.answerConfig) {\n\t\t\tthis.answerConfig = options.answerConfig;\n\t\t}\n\t\tif (options.maxChannelMessageSize && options.maxChannelMessageSize > 0) {\n\t\t\tthis.maxChannelMessageSize = options.maxChannelMessageSize;\n\t\t}\n\t\tif (options.webrtc) {\n\t\t\tthis.webrtc = options.webrtc;\n\t\t}\n\t}\n\n\tgetId() {\n\t\treturn this.id;\n\t}\n\n\tgetConnection() {\n\t\treturn this.connection;\n\t}\n\n\tgetChannel() {\n\t\treturn this.channel;\n\t}\n\n\tisReady() {\n\t\treturn this.channel && this.channel.readyState === \"open\";\n\t}\n\n\tisClosed() {\n\t\treturn !this.connection || this.connection.connectionState !== \"connected\";\n\t}\n\n\tready(): Promise<void> {\n\t\tif (this.isReady()) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\treturn this.waitOnce(\"connect\");\n\t}\n\n\tisInitiator() {\n\t\treturn this.initiator;\n\t}\n\n\tinit() {\n\t\tthis.initiator = true;\n\t\treturn this.createPeer();\n\t}\n\n\tclose() {\n\t\treturn this.internalClose(true);\n\t}\n\n\tsend(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n\t\tif (!this.channel) {\n\t\t\tthrow new Error(\"Channel not initialized\");\n\t\t}\n\t\tthis.channel.send(chunk as never);\n\t\treturn this;\n\t}\n\n\twrite(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n\t\tif (!this.channel) {\n\t\t\tthrow new Error(\"Channel not initialized\");\n\t\t}\n\t\treturn write(this.channel, chunk, this.maxChannelMessageSize);\n\t}\n\n\twritableStream() {\n\t\tif (!this.channel) {\n\t\t\tthrow new Error(\"Channel not initialized\");\n\t\t}\n\t\treturn writableStreamFromChannel(this.channel, this.maxChannelMessageSize);\n\t}\n\n\treadableStream() {\n\t\tif (!this.channel) {\n\t\t\tthrow new Error(\"Channel not initialized\");\n\t\t}\n\t\treturn readableStreamFromChannel(this.channel);\n\t}\n\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tasync signal(message: any) {\n\t\tif (!this.connection) {\n\t\t\tawait this.createPeer();\n\t\t}\n\n\t\tconsole.debug(`${this.id}: received signal message=${message.type}`);\n\t\tswitch (message.type) {\n\t\t\tcase \"renegotiate\": {\n\t\t\t\treturn this.negotiate();\n\t\t\t}\n\t\t\tcase \"transceiverRequest\": {\n\t\t\t\tif (!this.initiator) {\n\t\t\t\t\tthrow new Error(\"Invalid signal state\");\n\t\t\t\t}\n\t\t\t\tconst transceiverRequest = message.transceiverRequest;\n\t\t\t\tif (!transceiverRequest) {\n\t\t\t\t\tthrow new Error(\"Invalid signal message\");\n\t\t\t\t}\n\t\t\t\tawait this.addTransceiverFromKind(\n\t\t\t\t\ttransceiverRequest.kind,\n\t\t\t\t\ttransceiverRequest.init,\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tcase \"candidate\": {\n\t\t\t\tif (!this.connection) {\n\t\t\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t\t\t}\n\t\t\t\tconst candidateJSON = message.candidate;\n\t\t\t\tif (!candidateJSON) {\n\t\t\t\t\tthrow new Error(\"Invalid signal message\");\n\t\t\t\t}\n\t\t\t\tconst candidate = new this.webrtc.RTCIceCandidate(candidateJSON);\n\t\t\t\tif (this.connection.remoteDescription == null) {\n\t\t\t\t\tthis.pendingCandidates.push(candidate);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.connection.addIceCandidate(candidate);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tcase \"answer\":\n\t\t\tcase \"offer\":\n\t\t\tcase \"pranswer\":\n\t\t\tcase \"rollback\": {\n\t\t\t\tif (!this.connection) {\n\t\t\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t\t\t}\n\t\t\t\tconst sdp = message.sdp;\n\t\t\t\tif (!sdp) {\n\t\t\t\t\tthrow new Error(\"Invalid signal message\");\n\t\t\t\t}\n\t\t\t\tconst sessionDescription = new this.webrtc.RTCSessionDescription({\n\t\t\t\t\ttype: message.type,\n\t\t\t\t\tsdp,\n\t\t\t\t});\n\t\t\t\tawait this.connection.setRemoteDescription(sessionDescription);\n\t\t\t\tfor (const candidate of this.pendingCandidates) {\n\t\t\t\t\tawait this.connection.addIceCandidate(candidate);\n\t\t\t\t}\n\t\t\t\tthis.pendingCandidates.length = 0;\n\t\t\t\tif (this.connection?.remoteDescription?.type === \"offer\") {\n\t\t\t\t\tawait this.createAnswer();\n\t\t\t\t}\n\t\t\t\tthis.emit(\"negotiated\");\n\t\t\t\tconsole.debug(`${this.id}: set remote sdp`);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconsole.debug(`${this.id}: invalid signal type: ${message}`);\n\t\t\t\tthrow new Error(\"Invalid signal message type\");\n\t\t\t}\n\t\t}\n\t}\n\n\twaitOnce<K extends PeerEventNames>(event: K) {\n\t\treturn new Promise<EventEmitterReturnType<PeerEventArguments[K]>>(\n\t\t\t(resolve) => {\n\t\t\t\tthis.once(event, (...args) => {\n\t\t\t\t\tswitch (args.length) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tresolve(undefined as never);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tresolve(args[0]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tresolve(args as never);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\taddTransceiverFromKind(kind: string, init?: RTCRtpTransceiverInit) {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t}\n\n\t\tif (this.initiator) {\n\t\t\tconst transceiver = this.connection.addTransceiver(kind, init);\n\t\t\tthis.emit(\"transceiver\", transceiver);\n\t\t\treturn transceiver;\n\t\t}\n\t\tthis.internalSignal({\n\t\t\ttype: \"transceiverRequest\",\n\t\t\ttransceiverRequest: {\n\t\t\t\tkind,\n\t\t\t\tinit,\n\t\t\t},\n\t\t});\n\t\treturn null;\n\t}\n\n\taddTrack(track: MediaStreamTrack) {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t}\n\t\tconst sender = this.connection.addTrack(track);\n\t\treturn sender;\n\t}\n\n\tremoveTrack(sender: RTCRtpSender) {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t}\n\t\tthis.connection.removeTrack(sender);\n\t\treturn this;\n\t}\n\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tprivate internalSignal(message: any) {\n\t\tthis.emit(\"signal\", message);\n\t\treturn this;\n\t}\n\n\tprivate async negotiate() {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t}\n\t\tif (this.initiator) {\n\t\t\tawait this.createOffer();\n\t\t} else {\n\t\t\tthis.internalSignal({ type: \"renegotiate\", renegotiate: true });\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate async createOffer() {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t}\n\n\t\tconst offer = await this.connection.createOffer(this.offerConfig);\n\t\tif (!this.trickle) {\n\t\t\toffer.sdp = filterTrickle(offer.sdp);\n\t\t}\n\t\toffer.sdp = this.sdpTransform(offer.sdp);\n\t\tawait this.connection.setLocalDescription(offer);\n\t\tthis.internalSignal({ type: offer.type, sdp: offer.sdp });\n\t\treturn this;\n\t}\n\n\tprivate async createAnswer() {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"Connection not initialized\");\n\t\t}\n\n\t\tconst answer = await this.connection.createAnswer(this.answerConfig);\n\t\tif (!this.trickle) {\n\t\t\tanswer.sdp = filterTrickle(answer.sdp);\n\t\t}\n\t\tanswer.sdp = this.sdpTransform(answer.sdp);\n\t\tawait this.connection.setLocalDescription(answer);\n\t\tthis.internalSignal({ type: answer.type, sdp: answer.sdp });\n\t\treturn this;\n\t}\n\n\tprivate createPeer() {\n\t\tthis.internalClose(false);\n\n\t\tthis.connection = new this.webrtc.RTCPeerConnection(this.config);\n\t\tthis.connection.addEventListener(\n\t\t\t\"negotiationneeded\",\n\t\t\tthis.onNegotiationNeeded.bind(this),\n\t\t);\n\t\tthis.connection.addEventListener(\n\t\t\t\"iceconnectionstatechange\",\n\t\t\tthis.onICEConnectionStateChange.bind(this),\n\t\t);\n\t\tthis.connection.addEventListener(\n\t\t\t\"icegatheringstatechange\",\n\t\t\tthis.onICEGatheringStateChange.bind(this),\n\t\t);\n\t\tthis.connection.addEventListener(\n\t\t\t\"connectionstatechange\",\n\t\t\tthis.onConnectionStateChange.bind(this),\n\t\t);\n\t\tthis.connection.addEventListener(\n\t\t\t\"icecandidate\",\n\t\t\tthis.onICECandidate.bind(this),\n\t\t);\n\t\tthis.connection.addEventListener(\n\t\t\t\"signalingstatechange\",\n\t\t\tthis.onSignalingStateChange.bind(this),\n\t\t);\n\t\tthis.connection.addEventListener(\"track\", this.onTrackRemote.bind(this));\n\n\t\tif (this.initiator) {\n\t\t\tconst channel = this.connection.createDataChannel(\n\t\t\t\tthis.channelName,\n\t\t\t\tthis.channelConfig,\n\t\t\t);\n\t\t\tchannel.addEventListener(\"open\", this.onDataChannelOpen.bind(this));\n\t\t\tchannel.addEventListener(\"message\", this.onDataChannelMessage.bind(this));\n\t\t\tchannel.addEventListener(\"error\", this.onDataChannelError.bind(this));\n\t\t\tthis.channel = channel;\n\t\t} else {\n\t\t\tthis.connection.addEventListener(\n\t\t\t\t\"datachannel\",\n\t\t\t\tthis.onDataChannel.bind(this),\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate internalClose(triggerCallbacks = true) {\n\t\tif (this.channel) {\n\t\t\tthis.channel.close();\n\t\t\tthis.channel = undefined;\n\t\t}\n\n\t\tif (this.connection) {\n\t\t\tthis.connection.close();\n\t\t\tthis.connection = undefined;\n\t\t}\n\n\t\tif (triggerCallbacks) {\n\t\t\tthis.emit(\"close\");\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate onConnectionStateChange() {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (this.connection.connectionState) {\n\t\t\tcase \"connected\":\n\t\t\t\tconsole.debug(`${this.id}: connection state connected`);\n\t\t\t\tbreak;\n\t\t\tcase \"failed\":\n\t\t\t\tconsole.debug(`${this.id}: connection state failed`);\n\t\t\t\tthis.internalClose(true);\n\t\t\t\tbreak;\n\t\t\tcase \"disconnected\":\n\t\t\t\tconsole.debug(`${this.id}: connection state disconnected`);\n\t\t\t\tthis.internalClose(true);\n\t\t\t\tbreak;\n\t\t\tcase \"closed\":\n\t\t\t\tconsole.debug(`${this.id}: connection state closed`);\n\t\t\t\tthis.internalClose(true);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate onNegotiationNeeded() {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.negotiate();\n\t}\n\n\tprivate onICEConnectionStateChange() {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.debug(\n\t\t\t`${this.id}: ice connection state ${this.connection.iceConnectionState}`,\n\t\t);\n\t}\n\n\tprivate onICEGatheringStateChange() {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.debug(\n\t\t\t`${this.id}: ice gathering state ${this.connection.iceGatheringState}`,\n\t\t);\n\t}\n\n\tprivate onSignalingStateChange() {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\tconsole.debug(\n\t\t\t`${this.id}: signaling state ${this.connection.signalingState}`,\n\t\t);\n\t}\n\n\tprivate onICECandidate(event: RTCPeerConnectionIceEvent) {\n\t\tif (event.candidate) {\n\t\t\tthis.internalSignal({\n\t\t\t\ttype: \"candidate\",\n\t\t\t\tcandidate: event.candidate,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate onTrackRemote(event: RTCTrackEvent) {\n\t\tthis.emit(\"track\", event);\n\t}\n\n\tprivate onDataChannel(event: RTCDataChannelEvent) {\n\t\tconst channel = event.channel;\n\t\tthis.channel = channel;\n\t\tthis.channel.onopen = this.onDataChannelOpen.bind(this);\n\t\tthis.channel.onmessage = this.onDataChannelMessage.bind(this);\n\t\tthis.channel.onerror = this.onDataChannelError.bind(this);\n\t}\n\n\tprivate onDataChannelOpen() {\n\t\tconsole.debug(`${this.id}: data channel open`);\n\t\tthis.emit(\"connect\");\n\t}\n\n\tprivate onDataChannelMessage(\n\t\tevent: MessageEvent<string | Blob | ArrayBuffer | Uint8Array>,\n\t) {\n\t\tthis.emit(\"data\", event.data);\n\t}\n\n\tprivate onDataChannelError(event: Event) {\n\t\tthis.emit(\"error\", new Error(\"DataChannel error\", { cause: event }));\n\t}\n}\n\nfunction filterTrickle(sdp?: string) {\n\treturn sdp?.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction sdpTransform(sdp?: string) {\n\treturn sdp;\n}\nfunction asap() {\n\treturn new Promise<void>((resolve) => resolve());\n}\nfunction waitMS(ms: number) {\n\treturn new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction write(\n\tchannel: RTCDataChannel,\n\tchunk: string | Blob | ArrayBuffer | ArrayBufferView,\n\tmaxChannelMessageSize: number,\n) {\n\tif (typeof chunk === \"string\") {\n\t\tif (chunk.length < maxChannelMessageSize) {\n\t\t\tchannel.send(chunk);\n\t\t} else {\n\t\t\tlet offset = 0;\n\t\t\twhile (offset < chunk.length) {\n\t\t\t\tconst length = Math.min(maxChannelMessageSize, chunk.length - offset);\n\t\t\t\tchannel.send(chunk.substring(offset, offset + length));\n\t\t\t\toffset += length;\n\t\t\t}\n\t\t}\n\t} else if (chunk instanceof Blob) {\n\t\tif (chunk.size < maxChannelMessageSize) {\n\t\t\tchannel.send(chunk);\n\t\t} else {\n\t\t\tlet offset = 0;\n\t\t\twhile (offset < chunk.size) {\n\t\t\t\tconst length = Math.min(maxChannelMessageSize, chunk.size - offset);\n\t\t\t\tchannel.send(chunk.slice(offset, offset + length));\n\t\t\t\toffset += length;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet buffer: ArrayBuffer;\n\t\tif (chunk instanceof ArrayBuffer) {\n\t\t\tbuffer = chunk;\n\t\t} else {\n\t\t\tbuffer = chunk.buffer;\n\t\t}\n\t\tif (buffer.byteLength < maxChannelMessageSize) {\n\t\t\tchannel.send(buffer);\n\t\t} else {\n\t\t\tlet offset = 0;\n\t\t\twhile (offset < buffer.byteLength) {\n\t\t\t\tconst length = Math.min(\n\t\t\t\t\tmaxChannelMessageSize,\n\t\t\t\t\tbuffer.byteLength - offset,\n\t\t\t\t);\n\t\t\t\tchannel.send(buffer.slice(offset, offset + length));\n\t\t\t\toffset += length;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function writableStreamFromChannel(\n\tchannel: RTCDataChannel,\n\tmaxChannelMessageSize: number,\n) {\n\treturn new WritableStream({\n\t\twrite(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n\t\t\twrite(channel, chunk, maxChannelMessageSize);\n\t\t},\n\t});\n}\n\nexport function readableStreamFromChannel(channel: RTCDataChannel) {\n\tlet closed = false;\n\tlet closedController = false;\n\tconst queue: Array<string | Blob | ArrayBuffer> = [];\n\tconst pullQueue: Array<\n\t\t[\n\t\t\tresolve: (data: string | Blob | ArrayBuffer) => void,\n\t\t\treject: (error?: Error) => void,\n\t\t]\n\t> = [];\n\tfunction pull() {\n\t\treturn new Promise<string | Blob | ArrayBuffer>((resolve, reject) =>\n\t\t\tpullQueue.push([resolve, reject]),\n\t\t);\n\t}\n\tfunction onMessage(event: MessageEvent<string | Blob | ArrayBuffer>) {\n\t\tif (pullQueue.length) {\n\t\t\t// biome-ignore lint/style/noNonNullAssertion: checked above\n\t\t\tconst [resolve, _reject] = pullQueue.shift()!;\n\t\t\tresolve(event.data);\n\t\t} else {\n\t\t\tqueue.push(event.data);\n\t\t}\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\tconst onClose = () => {\n\t\tif (closed) {\n\t\t\treturn;\n\t\t}\n\t\tchannel.removeEventListener(\"message\", onMessage);\n\t\tchannel.removeEventListener(\"close\", onClose);\n\t\tclosed = true;\n\t\tfor (const [_resolve, reject] of pullQueue) {\n\t\t\treject(new Error(\"Stream closed\"));\n\t\t}\n\t\tpullQueue.length = 0;\n\t\tqueue.length = 0;\n\t};\n\tchannel.addEventListener(\"close\", onClose);\n\treturn new ReadableStream<string | Blob | ArrayBuffer>({\n\t\tasync pull(controller) {\n\t\t\tif (closed) {\n\t\t\t\tif (!closedController) {\n\t\t\t\t\tclosedController = true;\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (queue.length) {\n\t\t\t\tcontroller.enqueue(queue.shift());\n\t\t\t} else {\n\t\t\t\tcontroller.enqueue(await pull());\n\t\t\t}\n\t\t},\n\t\tcancel: onClose,\n\t});\n}\n"],"names":["DEFAULT_WEBRTC","RTCPeerConnection","RTCSessionDescription","RTCIceCandidate","Peer","EventEmitter","constructor","options","super","this","initiator","maxChannelMessageSize","trickle","sdpTransform","config","iceServers","pendingCandidates","webrtc","id","uuidv4","channelName","channelConfig","offerConfig","answerConfig","getId","getConnection","connection","getChannel","channel","isReady","readyState","isClosed","connectionState","ready","Promise","resolve","waitOnce","isInitiator","init","createPeer","close","internalClose","send","chunk","Error","write","writableStream","writableStreamFromChannel","readableStream","readableStreamFromChannel","signal","message","console","debug","type","negotiate","transceiverRequest","addTransceiverFromKind","kind","candidateJSON","candidate","remoteDescription","push","addIceCandidate","sdp","sessionDescription","setRemoteDescription","length","_b","_a","createAnswer","emit","event","once","args","undefined","transceiver","addTransceiver","internalSignal","addTrack","track","removeTrack","sender","createOffer","renegotiate","offer","filterTrickle","setLocalDescription","answer","addEventListener","onNegotiationNeeded","bind","onICEConnectionStateChange","onICEGatheringStateChange","onConnectionStateChange","onICECandidate","onSignalingStateChange","onTrackRemote","createDataChannel","onDataChannelOpen","onDataChannelMessage","onDataChannelError","onDataChannel","triggerCallbacks","iceConnectionState","iceGatheringState","signalingState","onopen","onmessage","onerror","data","cause","replace","offset","Math","min","substring","Blob","size","slice","buffer","ArrayBuffer","byteLength","WritableStream","closed","closedController","queue","pullQueue","onMessage","_reject","shift","onClose","removeEventListener","_resolve","reject","ReadableStream","pull","controller","enqueue","cancel"],"mappings":"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"}
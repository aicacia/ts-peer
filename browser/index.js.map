{"version":3,"file":"index.js","sources":["../src/Peer.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nconst defaultMaxChannelMessageSize = 16384;\n\nexport interface PeerOptions {\n  id?: string;\n  trickle?: boolean;\n  sdpTransform?: (sdp?: string) => string;\n  channelName?: string;\n  channelConfig?: RTCDataChannelInit;\n  config?: RTCConfiguration;\n  offerConfig?: RTCOfferOptions;\n  answerConfig?: RTCAnswerOptions;\n  maxChannelMessageSize?: number;\n  webrtc?: PeerWebRTC;\n}\n\nexport interface PeerWebRTC {\n  RTCPeerConnection: typeof RTCPeerConnection;\n  RTCSessionDescription: typeof RTCSessionDescription;\n  RTCIceCandidate: typeof RTCIceCandidate;\n}\n\nconst DEFAULT_WEBRTC: PeerWebRTC = {\n  RTCPeerConnection:\n    typeof RTCPeerConnection === \"undefined\"\n      ? (null as never)\n      : (RTCPeerConnection as never),\n  RTCSessionDescription:\n    typeof RTCSessionDescription === \"undefined\"\n      ? (null as never)\n      : (RTCSessionDescription as never),\n  RTCIceCandidate:\n    typeof RTCIceCandidate === \"undefined\"\n      ? (null as never)\n      : (RTCIceCandidate as never),\n};\n\ninterface PeerEvents {\n  signal(message: never): void;\n  connect(): void;\n  data(event: string | Blob | ArrayBuffer | Uint8Array): void;\n  error(error: Error): void;\n  close(): void;\n  transceiver(transceiver: RTCRtpTransceiver): void;\n  track(track: RTCTrackEvent): void;\n}\n\ntype PeerEventNames = EventEmitterTypes.EventNames<PeerEvents>;\ntype PeerEventArguments = EventEmitterTypes.ArgumentMap<PeerEvents>;\ntype EventEmitterReturnType<T> = T extends []\n  ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n    void\n  : T extends [infer R]\n  ? R\n  : T;\n\nexport class Peer extends EventEmitter<PeerEvents> {\n  private id: string;\n  private initiator = false;\n  private channelName: string;\n  private channelConfig?: RTCDataChannelInit;\n  private channel?: RTCDataChannel;\n  private maxChannelMessageSize = defaultMaxChannelMessageSize;\n  private trickle = true;\n  private sdpTransform = sdpTransform;\n  private config: RTCConfiguration = { iceServers: [] };\n  private connection?: RTCPeerConnection;\n  private offerConfig?: RTCOfferOptions;\n  private answerConfig?: RTCAnswerOptions;\n  private pendingCandidates: RTCIceCandidateInit[] = [];\n  private webrtc: PeerWebRTC = DEFAULT_WEBRTC;\n\n  constructor(options: PeerOptions) {\n    super();\n    this.id = options.id || uuidv4();\n    this.channelName = options.channelName || uuidv4();\n    if (options.channelConfig) {\n      this.channelConfig = options.channelConfig;\n    }\n    if (options.trickle === false) {\n      this.trickle = false;\n    }\n    if (options.sdpTransform) {\n      this.sdpTransform = options.sdpTransform;\n    }\n    if (options.config) {\n      this.config = options.config;\n    }\n    if (options.offerConfig) {\n      this.offerConfig = options.offerConfig;\n    }\n    if (options.answerConfig) {\n      this.answerConfig = options.answerConfig;\n    }\n    if (options.maxChannelMessageSize && options.maxChannelMessageSize > 0) {\n      this.maxChannelMessageSize = options.maxChannelMessageSize;\n    }\n    if (options.webrtc) {\n      this.webrtc = options.webrtc;\n    }\n  }\n\n  getId() {\n    return this.id;\n  }\n\n  getConnection() {\n    return this.connection;\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  isReady() {\n    return this.channel && this.channel.readyState === \"open\";\n  }\n\n  isClosed() {\n    return !this.connection || this.connection.connectionState !== \"connected\";\n  }\n\n  ready(): Promise<void> {\n    if (this.isReady()) {\n      return Promise.resolve();\n    }\n    return this.waitOnce(\"connect\");\n  }\n\n  isInitiator() {\n    return this.initiator;\n  }\n\n  init() {\n    this.initiator = true;\n    return this.createPeer();\n  }\n\n  close() {\n    return this.internalClose(true);\n  }\n\n  send(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    this.channel.send(chunk as never);\n    return this;\n  }\n\n  write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return write(this.channel, chunk, this.maxChannelMessageSize);\n  }\n\n  writableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return writableStreamFromChannel(this.channel, this.maxChannelMessageSize);\n  }\n\n  readableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return readableStreamFromChannel(this.channel);\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  async signal(message: any) {\n    if (!this.connection) {\n      await this.createPeer();\n    }\n\n    console.debug(`${this.id}: received signal message=${message.type}`);\n    switch (message.type) {\n      case \"renegotiate\": {\n        return this.needsNegotiation();\n      }\n      case \"transceiverRequest\": {\n        if (!this.initiator) {\n          throw new Error(\"Invalid signal state\");\n        }\n        const transceiverRequest = message.transceiverRequest;\n        if (!transceiverRequest) {\n          throw new Error(\"Invalid signal message\");\n        }\n        await this.addTransceiverFromKind(\n          transceiverRequest.kind,\n          transceiverRequest.init\n        );\n        return this;\n      }\n      case \"candidate\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const candidateJSON = message.candidate;\n        if (!candidateJSON) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const candidate = new this.webrtc.RTCIceCandidate(candidateJSON);\n        if (this.connection.remoteDescription == null) {\n          this.pendingCandidates.push(candidate);\n        } else {\n          await this.connection.addIceCandidate(candidate);\n        }\n        return this;\n      }\n      case \"answer\":\n      case \"offer\":\n      case \"pranswer\":\n      case \"rollback\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const sdp = message.sdp;\n        if (!sdp) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const sessionDescription = new this.webrtc.RTCSessionDescription({\n          type: message.type,\n          sdp,\n        });\n        console.debug(`${this.id}: setting remote sdp`);\n        await this.connection.setRemoteDescription(sessionDescription);\n        for (const candidate of this.pendingCandidates) {\n          await this.connection.addIceCandidate(candidate);\n        }\n        this.pendingCandidates.length = 0;\n        if (this.connection?.remoteDescription?.type === \"offer\") {\n          await this.createAnswer();\n        }\n        return this;\n      }\n      default: {\n        console.debug(`${this.id}: invalid signal type: ${message}`);\n        throw new Error(\"Invalid signal message type\");\n      }\n    }\n  }\n\n  waitOnce<K extends PeerEventNames>(event: K) {\n    return new Promise<EventEmitterReturnType<PeerEventArguments[K]>>(\n      (resolve) => {\n        this.once(event, (...args) => {\n          switch (args.length) {\n            case 0:\n              resolve(undefined as never);\n              break;\n            case 1:\n              resolve(args[0]);\n              break;\n            default:\n              resolve(args as never);\n              break;\n          }\n        });\n      }\n    );\n  }\n\n  addTransceiverFromKind(kind: string, init?: RTCRtpTransceiverInit) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      const transceiver = this.connection.addTransceiver(kind, init);\n      this.emit(\"transceiver\", transceiver);\n      return transceiver;\n    }\n    this.internalSignal({\n      type: \"transceiverRequest\",\n      transceiverRequest: {\n        kind,\n        init,\n      },\n    });\n    return null;\n  }\n\n  addTrack(track: MediaStreamTrack) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    const sender = this.connection.addTrack(track);\n    return sender;\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    this.connection.removeTrack(sender);\n    return this;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private internalSignal(message: any) {\n    this.emit(\"signal\", message);\n    return this;\n  }\n\n  private runningNegotiation = false;\n  private async needsNegotiation() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    if (this.initiator) {\n      if (!this.runningNegotiation) {\n        try {\n          this.runningNegotiation = true;\n          await asap();\n          await this.negotiate();\n        } finally {\n          this.runningNegotiation = false;\n        }\n      }\n    }\n    return this;\n  }\n\n  private async negotiate() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      await waitMS(0);\n      await this.createOffer();\n    } else {\n      this.internalSignal({ type: \"renegotiate\", renegotiate: true });\n    }\n    return this;\n  }\n\n  private async createOffer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const offer = await this.connection.createOffer(this.offerConfig);\n    if (!this.trickle) {\n      offer.sdp = filterTrickle(offer.sdp);\n    }\n    offer.sdp = this.sdpTransform(offer.sdp);\n    await this.connection.setLocalDescription(offer);\n    this.internalSignal({ type: offer.type, sdp: offer.sdp });\n    return this;\n  }\n\n  private async createAnswer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const answer = await this.connection.createAnswer(this.answerConfig);\n    if (!this.trickle) {\n      answer.sdp = filterTrickle(answer.sdp);\n    }\n    answer.sdp = this.sdpTransform(answer.sdp);\n    await this.connection.setLocalDescription(answer);\n    this.internalSignal({ type: answer.type, sdp: answer.sdp });\n    return this;\n  }\n\n  private createPeer() {\n    this.internalClose(false);\n\n    this.connection = new this.webrtc.RTCPeerConnection(this.config);\n    this.connection.addEventListener(\n      \"negotiationneeded\",\n      this.onNegotiationNeeded.bind(this)\n    );\n    this.connection.addEventListener(\n      \"iceconnectionstatechange\",\n      this.onICEConnectionStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"icegatheringstatechange\",\n      this.onICEGatheringStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"connectionstatechange\",\n      this.onConnectionStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"icecandidate\",\n      this.onICECandidate.bind(this)\n    );\n    this.connection.addEventListener(\"track\", this.onTrackRemote.bind(this));\n\n    if (this.initiator) {\n      const channel = this.connection.createDataChannel(\n        this.channelName,\n        this.channelConfig\n      );\n      channel.addEventListener(\"open\", this.onDataChannelOpen.bind(this));\n      channel.addEventListener(\"message\", this.onDataChannelMessage.bind(this));\n      channel.addEventListener(\"error\", this.onDataChannelError.bind(this));\n      this.channel = channel;\n    } else {\n      this.connection.addEventListener(\n        \"datachannel\",\n        this.onDataChannel.bind(this)\n      );\n    }\n    return this;\n  }\n\n  private internalClose(triggerCallbacks = true) {\n    if (this.channel) {\n      this.channel.close();\n      this.channel = undefined;\n    }\n\n    if (this.connection) {\n      this.connection.close();\n      this.connection = undefined;\n    }\n\n    if (triggerCallbacks) {\n      this.emit(\"close\");\n    }\n    return this;\n  }\n\n  private onConnectionStateChange() {\n    if (!this.connection) {\n      return;\n    }\n\n    switch (this.connection.connectionState) {\n      case \"connected\":\n        console.debug(`${this.id}: connected`);\n        break;\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      case \"failed\":\n        console.debug(`${this.id}: failed`);\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      case \"disconnected\":\n        console.debug(`${this.id}: disconnected`);\n      case \"closed\":\n        console.debug(`${this.id}: closed`);\n        this.internalClose(true);\n        break;\n    }\n  }\n\n  private onNegotiationNeeded() {\n    if (!this.connection) {\n      return;\n    }\n    return this.needsNegotiation();\n  }\n\n  private onICEConnectionStateChange() {\n    if (!this.connection) {\n      return;\n    }\n\n    switch (this.connection.iceConnectionState) {\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      case \"new\":\n        console.debug(`${this.id}: new`);\n      case \"checking\":\n        console.debug(`${this.id}: checking`);\n        break;\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      case \"connected\":\n        console.debug(`${this.id}: connected`);\n      case \"completed\":\n        console.debug(`${this.id}: completed`);\n        break;\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      case \"failed\":\n        console.debug(`${this.id}: failed`);\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      case \"disconnected\":\n        console.debug(`${this.id}: disconnected`);\n      case \"closed\":\n        console.debug(`${this.id}: closed`);\n        this.internalClose(true);\n        break;\n    }\n  }\n\n  private onICEGatheringStateChange() {\n    if (!this.connection) {\n      return;\n    }\n\n    switch (this.connection.iceGatheringState) {\n      case \"new\":\n      case \"gathering\":\n        break;\n      case \"complete\":\n        break;\n    }\n  }\n\n  private onICECandidate(event: RTCPeerConnectionIceEvent) {\n    if (event.candidate) {\n      this.internalSignal({\n        type: \"candidate\",\n        candidate: event.candidate,\n      });\n    }\n  }\n\n  private onTrackRemote(event: RTCTrackEvent) {\n    this.emit(\"track\", event);\n  }\n\n  private onDataChannel(event: RTCDataChannelEvent) {\n    const channel = event.channel;\n    this.channel = channel;\n    this.channel.onopen = this.onDataChannelOpen.bind(this);\n    this.channel.onmessage = this.onDataChannelMessage.bind(this);\n    this.channel.onerror = this.onDataChannelError.bind(this);\n  }\n\n  private onDataChannelOpen() {\n    console.debug(`${this.id}: data channel open`);\n    this.emit(\"connect\");\n  }\n\n  private onDataChannelMessage(\n    event: MessageEvent<string | Blob | ArrayBuffer | Uint8Array>\n  ) {\n    this.emit(\"data\", event.data);\n  }\n\n  private onDataChannelError(event: Event) {\n    this.emit(\"error\", new Error(\"DataChannel error\", { cause: event }));\n  }\n}\n\nfunction filterTrickle(sdp?: string) {\n  return sdp?.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction sdpTransform(sdp?: string) {\n  return sdp;\n}\nfunction asap() {\n  return new Promise<void>((resolve) => resolve());\n}\nfunction waitMS(ms: number) {\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction write(\n  channel: RTCDataChannel,\n  chunk: string | Blob | ArrayBuffer | ArrayBufferView,\n  maxChannelMessageSize: number\n) {\n  if (typeof chunk === \"string\") {\n    if (chunk.length < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.length) {\n        const length = Math.min(maxChannelMessageSize, chunk.length - offset);\n        channel.send(chunk.substring(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else if (chunk instanceof Blob) {\n    if (chunk.size < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.size) {\n        const length = Math.min(maxChannelMessageSize, chunk.size - offset);\n        channel.send(chunk.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else {\n    let buffer: ArrayBuffer;\n    if (chunk instanceof ArrayBuffer) {\n      buffer = chunk;\n    } else {\n      buffer = chunk.buffer;\n    }\n    if (buffer.byteLength < maxChannelMessageSize) {\n      channel.send(buffer);\n    } else {\n      let offset = 0;\n      while (offset < buffer.byteLength) {\n        const length = Math.min(\n          maxChannelMessageSize,\n          buffer.byteLength - offset\n        );\n        channel.send(buffer.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  }\n}\n\nexport function writableStreamFromChannel(\n  channel: RTCDataChannel,\n  maxChannelMessageSize: number\n) {\n  return new WritableStream({\n    write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n      write(channel, chunk, maxChannelMessageSize);\n    },\n  });\n}\n\nexport function readableStreamFromChannel(channel: RTCDataChannel) {\n  let closed = false;\n  let closedController = false;\n  const queue: Array<string | Blob | ArrayBuffer> = [];\n  const pullQueue: Array<\n    [\n      resolve: (data: string | Blob | ArrayBuffer) => void,\n      reject: (error?: Error) => void\n    ]\n  > = [];\n  function pull() {\n    return new Promise<string | Blob | ArrayBuffer>((resolve, reject) =>\n      pullQueue.push([resolve, reject])\n    );\n  }\n  function onMessage(event: MessageEvent<string | Blob | ArrayBuffer>) {\n    if (pullQueue.length) {\n      // biome-ignore lint/style/noNonNullAssertion: checked above\n      const [resolve, _reject] = pullQueue.shift()!;\n      resolve(event.data);\n    } else {\n      queue.push(event.data);\n    }\n  }\n  channel.addEventListener(\"message\", onMessage);\n  const onClose = () => {\n    if (closed) {\n      return;\n    }\n    channel.removeEventListener(\"message\", onMessage);\n    channel.removeEventListener(\"close\", onClose);\n    closed = true;\n    for (const [_resolve, reject] of pullQueue) {\n      reject(new Error(\"Stream closed\"));\n    }\n    pullQueue.length = 0;\n    queue.length = 0;\n  };\n  channel.addEventListener(\"close\", onClose);\n  return new ReadableStream<string | Blob | ArrayBuffer>({\n    async pull(controller) {\n      if (closed) {\n        if (!closedController) {\n          closedController = true;\n          controller.close();\n        }\n        return;\n      }\n      if (queue.length) {\n        controller.enqueue(queue.shift());\n      } else {\n        controller.enqueue(await pull());\n      }\n    },\n    cancel: onClose,\n  });\n}\n"],"names":["DEFAULT_WEBRTC","RTCPeerConnection","RTCSessionDescription","RTCIceCandidate","Peer","EventEmitter","constructor","options","super","this","initiator","maxChannelMessageSize","trickle","sdpTransform","config","iceServers","pendingCandidates","webrtc","runningNegotiation","id","uuidv4","channelName","channelConfig","offerConfig","answerConfig","getId","getConnection","connection","getChannel","channel","isReady","readyState","isClosed","connectionState","ready","Promise","resolve","waitOnce","isInitiator","init","createPeer","close","internalClose","send","chunk","Error","write","writableStream","writableStreamFromChannel","readableStream","readableStreamFromChannel","signal","message","console","debug","type","needsNegotiation","transceiverRequest","addTransceiverFromKind","kind","candidateJSON","candidate","remoteDescription","push","addIceCandidate","sdp","sessionDescription","setRemoteDescription","length","_b","_a","createAnswer","event","once","args","undefined","transceiver","addTransceiver","emit","internalSignal","addTrack","track","removeTrack","sender","negotiate","ms","setTimeout","createOffer","renegotiate","offer","filterTrickle","setLocalDescription","answer","addEventListener","onNegotiationNeeded","bind","onICEConnectionStateChange","onICEGatheringStateChange","onConnectionStateChange","onICECandidate","onTrackRemote","createDataChannel","onDataChannelOpen","onDataChannelMessage","onDataChannelError","onDataChannel","triggerCallbacks","iceConnectionState","iceGatheringState","onopen","onmessage","onerror","data","cause","replace","offset","Math","min","substring","Blob","size","slice","buffer","ArrayBuffer","byteLength","WritableStream","closed","closedController","queue","pullQueue","onMessage","_reject","shift","onClose","removeEventListener","_resolve","reject","ReadableStream","pull","controller","enqueue","cancel"],"mappings":"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"}
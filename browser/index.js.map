{"version":3,"file":"index.js","sources":["../src/Peer.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nconst defaultMaxChannelMessageSize = 16384;\n\nexport interface PeerOptions {\n  id?: string;\n  sdpTransform?: (sdp?: string) => string;\n  channelName?: string;\n  channelConfig?: RTCDataChannelInit;\n  config?: RTCConfiguration;\n  offerConfig?: RTCOfferOptions;\n  answerConfig?: RTCAnswerOptions;\n  maxChannelMessageSize?: number;\n  webrtc?: PeerWebRTC;\n}\n\nexport interface PeerWebRTC {\n  RTCPeerConnection: typeof RTCPeerConnection;\n  RTCSessionDescription: typeof RTCSessionDescription;\n  RTCIceCandidate: typeof RTCIceCandidate;\n}\n\nconst DEFAULT_WEBRTC: PeerWebRTC = {\n  RTCPeerConnection:\n    typeof RTCPeerConnection === \"undefined\"\n      ? (null as never)\n      : (RTCPeerConnection as never),\n  RTCSessionDescription:\n    typeof RTCSessionDescription === \"undefined\"\n      ? (null as never)\n      : (RTCSessionDescription as never),\n  RTCIceCandidate:\n    typeof RTCIceCandidate === \"undefined\"\n      ? (null as never)\n      : (RTCIceCandidate as never),\n};\n\ninterface PeerEvents {\n  signal(message: never): void;\n  connect(): void;\n  data(event: string | Blob | ArrayBuffer | Uint8Array): void;\n  error(error: Error): void;\n  close(): void;\n  transceiver(transceiver: RTCRtpTransceiver): void;\n  track(track: RTCTrackEvent): void;\n  negotiated(): void;\n}\n\ntype PeerEventNames = EventEmitterTypes.EventNames<PeerEvents>;\ntype PeerEventArguments = EventEmitterTypes.ArgumentMap<PeerEvents>;\ntype EventEmitterReturnType<T> = T extends []\n  ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n    void\n  : T extends [infer R]\n  ? R\n  : T;\n\nexport class Peer extends EventEmitter<PeerEvents> {\n  private id: string;\n  private initiator = false;\n  private channelName: string;\n  private channelConfig?: RTCDataChannelInit;\n  private channel?: RTCDataChannel;\n  private maxChannelMessageSize = defaultMaxChannelMessageSize;\n  private sdpTransform = sdpTransform;\n  private config: RTCConfiguration = { iceServers: [] };\n  private connection?: RTCPeerConnection;\n  private offerConfig?: RTCOfferOptions;\n  private answerConfig?: RTCAnswerOptions;\n  private pendingCandidates: RTCIceCandidateInit[] = [];\n  private webrtc: PeerWebRTC = DEFAULT_WEBRTC;\n\n  constructor(options: PeerOptions) {\n    super();\n    this.id = options.id || uuidv4();\n    this.channelName = options.channelName || uuidv4();\n    if (options.channelConfig) {\n      this.channelConfig = options.channelConfig;\n    }\n    if (options.sdpTransform) {\n      this.sdpTransform = options.sdpTransform;\n    }\n    if (options.config) {\n      this.config = options.config;\n    }\n    if (options.offerConfig) {\n      this.offerConfig = options.offerConfig;\n    }\n    if (options.answerConfig) {\n      this.answerConfig = options.answerConfig;\n    }\n    if (options.maxChannelMessageSize && options.maxChannelMessageSize > 0) {\n      this.maxChannelMessageSize = options.maxChannelMessageSize;\n    }\n    if (options.webrtc) {\n      this.webrtc = options.webrtc;\n    }\n  }\n\n  getId() {\n    return this.id;\n  }\n\n  getConnection() {\n    return this.connection;\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  isReady() {\n    return this.channel && this.channel.readyState === \"open\";\n  }\n\n  isClosed() {\n    return !this.connection || this.connection.connectionState !== \"connected\";\n  }\n\n  ready(): Promise<void> {\n    if (this.isReady()) {\n      return Promise.resolve();\n    }\n    return this.waitOnce(\"connect\");\n  }\n\n  isInitiator() {\n    return this.initiator;\n  }\n\n  init() {\n    this.initiator = true;\n    return this.createPeer();\n  }\n\n  close() {\n    return this.internalClose(true);\n  }\n\n  send(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    this.channel.send(chunk as never);\n    return this;\n  }\n\n  write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return write(this.channel, chunk, this.maxChannelMessageSize);\n  }\n\n  writableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return writableStreamFromChannel(this.channel, this.maxChannelMessageSize);\n  }\n\n  readableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return readableStreamFromChannel(this.channel);\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  async signal(message: any) {\n    if (!this.connection) {\n      await this.createPeer();\n    }\n\n    console.debug(`${this.id}: received signal message=${message.type}`);\n    switch (message.type) {\n      case \"renegotiate\": {\n        return this.negotiate();\n      }\n      case \"transceiverRequest\": {\n        if (!this.initiator) {\n          throw new Error(\"Invalid signal state\");\n        }\n        const transceiverRequest = message.transceiverRequest;\n        if (!transceiverRequest) {\n          throw new Error(\"Invalid signal message\");\n        }\n        await this.addTransceiverFromKind(\n          transceiverRequest.kind,\n          transceiverRequest.init\n        );\n        return this;\n      }\n      case \"candidate\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const candidateJSON = message.candidate;\n        if (!candidateJSON) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const candidate = new this.webrtc.RTCIceCandidate(candidateJSON);\n        if (this.connection.remoteDescription == null) {\n          this.pendingCandidates.push(candidate);\n        } else {\n          await this.connection.addIceCandidate(candidate);\n        }\n        return this;\n      }\n      case \"answer\":\n      case \"offer\":\n      case \"pranswer\":\n      case \"rollback\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const sdp = message.sdp;\n        if (!sdp) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const sessionDescription = new this.webrtc.RTCSessionDescription({\n          type: message.type,\n          sdp,\n        });\n        await this.connection.setRemoteDescription(sessionDescription);\n        for (const candidate of this.pendingCandidates) {\n          await this.connection.addIceCandidate(candidate);\n        }\n        this.pendingCandidates.length = 0;\n        if (this.connection?.remoteDescription?.type === \"offer\") {\n          await this.createAnswer();\n        }\n        this.emit(\"negotiated\");\n        console.debug(`${this.id}: set remote sdp`);\n        return this;\n      }\n      default: {\n        console.debug(`${this.id}: invalid signal type: ${message}`);\n        throw new Error(\"Invalid signal message type\");\n      }\n    }\n  }\n\n  waitOnce<K extends PeerEventNames>(event: K) {\n    return new Promise<EventEmitterReturnType<PeerEventArguments[K]>>(\n      (resolve) => {\n        this.once(event, (...args) => {\n          switch (args.length) {\n            case 0:\n              resolve(undefined as never);\n              break;\n            case 1:\n              resolve(args[0]);\n              break;\n            default:\n              resolve(args as never);\n              break;\n          }\n        });\n      }\n    );\n  }\n\n  addTransceiverFromKind(kind: string, init?: RTCRtpTransceiverInit) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      const transceiver = this.connection.addTransceiver(kind, init);\n      this.emit(\"transceiver\", transceiver);\n      return transceiver;\n    }\n    this.internalSignal({\n      type: \"transceiverRequest\",\n      transceiverRequest: {\n        kind,\n        init,\n      },\n    });\n    return null;\n  }\n\n  addTrack(track: MediaStreamTrack) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    const sender = this.connection.addTrack(track);\n    return sender;\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    this.connection.removeTrack(sender);\n    return this;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private internalSignal(message: any) {\n    this.emit(\"signal\", message);\n    return this;\n  }\n\n  public async negotiate() {\n    if (this.initiator) {\n      await this.createOffer();\n    } else {\n      this.internalSignal({ type: \"renegotiate\", renegotiate: true });\n    }\n    return this;\n  }\n\n  private async createOffer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const offer = await this.connection.createOffer(this.offerConfig);\n    offer.sdp = this.sdpTransform(offer.sdp);\n    await this.connection.setLocalDescription(offer);\n    this.internalSignal({ type: offer.type, sdp: offer.sdp });\n    return this;\n  }\n\n  private async createAnswer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const answer = await this.connection.createAnswer(this.answerConfig);\n    answer.sdp = this.sdpTransform(answer.sdp);\n    await this.connection.setLocalDescription(answer);\n    this.internalSignal({ type: answer.type, sdp: answer.sdp });\n    return this;\n  }\n\n  private createPeer() {\n    this.internalClose(false);\n\n    this.connection = new this.webrtc.RTCPeerConnection(this.config);\n    this.connection.addEventListener(\n      \"negotiationneeded\",\n      this.onNegotiationNeeded.bind(this)\n    );\n    this.connection.addEventListener(\n      \"iceconnectionstatechange\",\n      this.onICEConnectionStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"icegatheringstatechange\",\n      this.onICEGatheringStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"connectionstatechange\",\n      this.onConnectionStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"icecandidate\",\n      this.onICECandidate.bind(this)\n    );\n    this.connection.addEventListener(\n      \"signalingstatechange\",\n      this.onSignalingStateChange.bind(this)\n    );\n    this.connection.addEventListener(\"track\", this.onTrackRemote.bind(this));\n\n    if (this.initiator) {\n      const channel = this.connection.createDataChannel(\n        this.channelName,\n        this.channelConfig\n      );\n      channel.addEventListener(\"open\", this.onDataChannelOpen.bind(this));\n      channel.addEventListener(\"message\", this.onDataChannelMessage.bind(this));\n      channel.addEventListener(\"error\", this.onDataChannelError.bind(this));\n      this.channel = channel;\n    } else {\n      this.connection.addEventListener(\n        \"datachannel\",\n        this.onDataChannel.bind(this)\n      );\n    }\n    return this;\n  }\n\n  private internalClose(triggerCallbacks = true) {\n    if (this.channel) {\n      this.channel.close();\n      this.channel = undefined;\n    }\n\n    if (this.connection) {\n      this.connection.close();\n      this.connection = undefined;\n    }\n\n    if (triggerCallbacks) {\n      this.emit(\"close\");\n    }\n    return this;\n  }\n\n  private onConnectionStateChange() {\n    if (!this.connection) {\n      return;\n    }\n\n    console.debug(\n      `${this.id}: connection state ${this.connection.connectionState}`\n    );\n    switch (this.connection.connectionState) {\n      case \"failed\":\n      case \"disconnected\":\n      case \"closed\":\n        this.internalClose(true);\n        break;\n    }\n  }\n\n  private onNegotiationNeeded() {\n    if (!this.connection) {\n      return;\n    }\n    return this.negotiate();\n  }\n\n  private onICEConnectionStateChange() {\n    if (!this.connection) {\n      return;\n    }\n\n    console.debug(\n      `${this.id}: ice connection state ${this.connection.iceConnectionState}`\n    );\n  }\n\n  private onICEGatheringStateChange() {\n    if (!this.connection) {\n      return;\n    }\n\n    console.debug(\n      `${this.id}: ice gathering state ${this.connection.iceGatheringState}`\n    );\n  }\n\n  private onSignalingStateChange() {\n    if (!this.connection) {\n      return;\n    }\n    console.debug(\n      `${this.id}: signaling state ${this.connection.signalingState}`\n    );\n  }\n\n  private onICECandidate(event: RTCPeerConnectionIceEvent) {\n    if (event.candidate) {\n      this.internalSignal({\n        type: \"candidate\",\n        candidate: event.candidate,\n      });\n    }\n  }\n\n  private onTrackRemote(event: RTCTrackEvent) {\n    this.emit(\"track\", event);\n  }\n\n  private onDataChannel(event: RTCDataChannelEvent) {\n    const channel = event.channel;\n    this.channel = channel;\n    this.channel.onopen = this.onDataChannelOpen.bind(this);\n    this.channel.onmessage = this.onDataChannelMessage.bind(this);\n    this.channel.onerror = this.onDataChannelError.bind(this);\n  }\n\n  private onDataChannelOpen() {\n    console.debug(`${this.id}: data channel open`);\n    this.emit(\"connect\");\n  }\n\n  private onDataChannelMessage(\n    event: MessageEvent<string | Blob | ArrayBuffer | Uint8Array>\n  ) {\n    this.emit(\"data\", event.data);\n  }\n\n  private onDataChannelError(event: Event) {\n    this.emit(\"error\", new Error(\"DataChannel error\", { cause: event }));\n  }\n}\n\nfunction sdpTransform(sdp?: string) {\n  return sdp;\n}\nfunction asap() {\n  return new Promise<void>((resolve) => resolve());\n}\nfunction waitMS(ms: number) {\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction write(\n  channel: RTCDataChannel,\n  chunk: string | Blob | ArrayBuffer | ArrayBufferView,\n  maxChannelMessageSize: number\n) {\n  if (typeof chunk === \"string\") {\n    if (chunk.length < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.length) {\n        const length = Math.min(maxChannelMessageSize, chunk.length - offset);\n        channel.send(chunk.substring(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else if (chunk instanceof Blob) {\n    if (chunk.size < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.size) {\n        const length = Math.min(maxChannelMessageSize, chunk.size - offset);\n        channel.send(chunk.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else {\n    let buffer: ArrayBuffer;\n    if (chunk instanceof ArrayBuffer) {\n      buffer = chunk;\n    } else {\n      buffer = chunk.buffer;\n    }\n    if (buffer.byteLength < maxChannelMessageSize) {\n      channel.send(buffer);\n    } else {\n      let offset = 0;\n      while (offset < buffer.byteLength) {\n        const length = Math.min(\n          maxChannelMessageSize,\n          buffer.byteLength - offset\n        );\n        channel.send(buffer.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  }\n}\n\nexport function writableStreamFromChannel(\n  channel: RTCDataChannel,\n  maxChannelMessageSize: number\n) {\n  return new WritableStream({\n    write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n      write(channel, chunk, maxChannelMessageSize);\n    },\n  });\n}\n\nexport function readableStreamFromChannel(channel: RTCDataChannel) {\n  let closed = false;\n  let closedController = false;\n  const queue: Array<string | Blob | ArrayBuffer> = [];\n  const pullQueue: Array<\n    [\n      resolve: (data: string | Blob | ArrayBuffer) => void,\n      reject: (error?: Error) => void\n    ]\n  > = [];\n  function pull() {\n    return new Promise<string | Blob | ArrayBuffer>((resolve, reject) =>\n      pullQueue.push([resolve, reject])\n    );\n  }\n  function onMessage(event: MessageEvent<string | Blob | ArrayBuffer>) {\n    if (pullQueue.length) {\n      // biome-ignore lint/style/noNonNullAssertion: checked above\n      const [resolve, _reject] = pullQueue.shift()!;\n      resolve(event.data);\n    } else {\n      queue.push(event.data);\n    }\n  }\n  channel.addEventListener(\"message\", onMessage);\n  const onClose = () => {\n    if (closed) {\n      return;\n    }\n    channel.removeEventListener(\"message\", onMessage);\n    channel.removeEventListener(\"close\", onClose);\n    closed = true;\n    for (const [_resolve, reject] of pullQueue) {\n      reject(new Error(\"Stream closed\"));\n    }\n    pullQueue.length = 0;\n    queue.length = 0;\n  };\n  channel.addEventListener(\"close\", onClose);\n  return new ReadableStream<string | Blob | ArrayBuffer>({\n    async pull(controller) {\n      if (closed) {\n        if (!closedController) {\n          closedController = true;\n          controller.close();\n        }\n        return;\n      }\n      if (queue.length) {\n        controller.enqueue(queue.shift());\n      } else {\n        controller.enqueue(await pull());\n      }\n    },\n    cancel: onClose,\n  });\n}\n"],"names":["DEFAULT_WEBRTC","RTCPeerConnection","RTCSessionDescription","RTCIceCandidate","Peer","EventEmitter","constructor","options","super","this","initiator","maxChannelMessageSize","sdpTransform","config","iceServers","pendingCandidates","webrtc","id","uuidv4","channelName","channelConfig","offerConfig","answerConfig","getId","getConnection","connection","getChannel","channel","isReady","readyState","isClosed","connectionState","ready","Promise","resolve","waitOnce","isInitiator","init","createPeer","close","internalClose","send","chunk","Error","write","writableStream","writableStreamFromChannel","readableStream","readableStreamFromChannel","signal","message","console","debug","type","negotiate","transceiverRequest","addTransceiverFromKind","kind","candidateJSON","candidate","remoteDescription","push","addIceCandidate","sdp","sessionDescription","setRemoteDescription","length","_b","_a","createAnswer","emit","event","once","args","undefined","transceiver","addTransceiver","internalSignal","addTrack","track","removeTrack","sender","createOffer","renegotiate","offer","setLocalDescription","answer","addEventListener","onNegotiationNeeded","bind","onICEConnectionStateChange","onICEGatheringStateChange","onConnectionStateChange","onICECandidate","onSignalingStateChange","onTrackRemote","createDataChannel","onDataChannelOpen","onDataChannelMessage","onDataChannelError","onDataChannel","triggerCallbacks","iceConnectionState","iceGatheringState","signalingState","onopen","onmessage","onerror","data","cause","offset","Math","min","substring","Blob","size","slice","buffer","ArrayBuffer","byteLength","WritableStream","closed","closedController","queue","pullQueue","onMessage","_reject","shift","onClose","removeEventListener","_resolve","reject","ReadableStream","pull","controller","enqueue","cancel"],"mappings":"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"}
{"version":3,"file":"index.js","sources":["../src/Peer.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nconst defaultMaxChannelMessageSize = 16384;\n\nexport interface PeerOptions {\n  id?: string;\n  trickle?: boolean;\n  sdpTransform?: (sdp?: string) => string;\n  channelName?: string;\n  channelConfig?: RTCDataChannelInit;\n  config?: RTCConfiguration;\n  offerConfig?: RTCOfferOptions;\n  answerConfig?: RTCAnswerOptions;\n  maxChannelMessageSize?: number;\n  webrtc?: PeerWebRTC;\n}\n\nexport interface PeerWebRTC {\n  RTCPeerConnection: typeof RTCPeerConnection;\n  RTCSessionDescription: typeof RTCSessionDescription;\n  RTCIceCandidate: typeof RTCIceCandidate;\n}\n\nconst DEFAULT_WEBRTC: PeerWebRTC = {\n  RTCPeerConnection:\n    typeof RTCPeerConnection === \"undefined\"\n      ? (null as never)\n      : (RTCPeerConnection as never),\n  RTCSessionDescription:\n    typeof RTCSessionDescription === \"undefined\"\n      ? (null as never)\n      : (RTCSessionDescription as never),\n  RTCIceCandidate:\n    typeof RTCIceCandidate === \"undefined\"\n      ? (null as never)\n      : (RTCIceCandidate as never),\n};\n\ninterface PeerEvents {\n  signal(message: never): void;\n  connect(): void;\n  data(event: string | Blob | ArrayBuffer | Uint8Array): void;\n  error(error: Error): void;\n  close(): void;\n  transceiver(transceiver: RTCRtpTransceiver): void;\n  track(track: RTCTrackEvent): void;\n}\n\ntype PeerEventNames = EventEmitterTypes.EventNames<PeerEvents>;\ntype PeerEventArguments = EventEmitterTypes.ArgumentMap<PeerEvents>;\ntype ExtractSingleTuple<T> = T extends [infer R] ? R : T;\n\nexport class Peer extends EventEmitter<PeerEvents> {\n  private id: string;\n  private initiator = false;\n  private channelName: string;\n  private channelConfig?: RTCDataChannelInit;\n  private channel?: RTCDataChannel;\n  private maxChannelMessageSize = defaultMaxChannelMessageSize;\n  private trickle = true;\n  private sdpTransform = sdpTransform;\n  private config: RTCConfiguration = { iceServers: [] };\n  private connection?: RTCPeerConnection;\n  private offerConfig?: RTCOfferOptions;\n  private answerConfig?: RTCAnswerOptions;\n  private pendingCandidates: RTCIceCandidateInit[] = [];\n  private webrtc: PeerWebRTC = DEFAULT_WEBRTC;\n\n  constructor(options: PeerOptions) {\n    super();\n    this.id = options.id || uuidv4();\n    this.channelName = options.channelName || uuidv4();\n    if (options.channelConfig) {\n      this.channelConfig = options.channelConfig;\n    }\n    if (options.trickle === false) {\n      this.trickle = false;\n    }\n    if (options.sdpTransform) {\n      this.sdpTransform = options.sdpTransform;\n    }\n    if (options.config) {\n      this.config = options.config;\n    }\n    if (options.offerConfig) {\n      this.offerConfig = options.offerConfig;\n    }\n    if (options.answerConfig) {\n      this.answerConfig = options.answerConfig;\n    }\n    if (options.maxChannelMessageSize && options.maxChannelMessageSize > 0) {\n      this.maxChannelMessageSize = options.maxChannelMessageSize;\n    }\n    if (options.webrtc) {\n      this.webrtc = options.webrtc;\n    }\n  }\n\n  getId() {\n    return this.id;\n  }\n\n  getConnection() {\n    return this.connection;\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  isReady() {\n    return this.channel && this.channel.readyState === \"open\";\n  }\n\n  isClosed() {\n    return !this.connection || this.connection.connectionState !== \"connected\";\n  }\n\n  isInitiator() {\n    return this.initiator;\n  }\n\n  init() {\n    this.initiator = true;\n    this.createPeer();\n    return this.needsNegotiation();\n  }\n\n  close() {\n    return this.internalClose(true);\n  }\n\n  send(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    this.channel.send(chunk as never);\n    return this;\n  }\n\n  write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return write(this.channel, chunk, this.maxChannelMessageSize);\n  }\n\n  writableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return writableStreamFromChannel(this.channel, this.maxChannelMessageSize);\n  }\n\n  readableStream() {\n    if (!this.channel) {\n      throw new Error(\"Channel not initialized\");\n    }\n    return readableStreamFromChannel(this.channel);\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  async signal(message: any) {\n    if (!this.connection) {\n      await this.createPeer();\n    }\n\n    console.debug(`${this.id}: received signal message=${message.type}`);\n    switch (message.type) {\n      case \"renegotiate\": {\n        return this.needsNegotiation();\n      }\n      case \"transceiverRequest\": {\n        if (!this.initiator) {\n          throw new Error(\"Invalid signal state\");\n        }\n        const transceiverRequest = message.transceiverRequest;\n        if (!transceiverRequest) {\n          throw new Error(\"Invalid signal message\");\n        }\n        await this.addTransceiverFromKind(\n          transceiverRequest.kind,\n          transceiverRequest.init\n        );\n        return this;\n      }\n      case \"candidate\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const candidateJSON = message.candidate;\n        if (!candidateJSON) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const candidate = new this.webrtc.RTCIceCandidate(candidateJSON);\n        if (this.connection.remoteDescription == null) {\n          this.pendingCandidates.push(candidate);\n        } else {\n          await this.connection.addIceCandidate(candidate);\n        }\n        return this;\n      }\n      case \"answer\":\n      case \"offer\":\n      case \"pranswer\":\n      case \"rollback\": {\n        if (!this.connection) {\n          throw new Error(\"Connection not initialized\");\n        }\n        const sdp = message.sdp;\n        if (!sdp) {\n          throw new Error(\"Invalid signal message\");\n        }\n        const sessionDescription = new this.webrtc.RTCSessionDescription({\n          type: message.type,\n          sdp,\n        });\n        console.debug(`${this.id}: setting remote sdp`);\n        await this.connection.setRemoteDescription(sessionDescription);\n        for (const candidate of this.pendingCandidates) {\n          await this.connection.addIceCandidate(candidate);\n        }\n        this.pendingCandidates.length = 0;\n        if (this.connection?.remoteDescription?.type === \"offer\") {\n          await this.createAnswer();\n        }\n        return this;\n      }\n      default: {\n        console.debug(`${this.id}: invalid signal type: ${message}`);\n        throw new Error(\"Invalid signal message type\");\n      }\n    }\n  }\n\n  waitOnce<K extends PeerEventNames>(event: K) {\n    return new Promise<ExtractSingleTuple<PeerEventArguments[K]>>((resolve) => {\n      this.once(event, (...args) => {\n        if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args as never);\n        }\n      });\n    });\n  }\n\n  addTransceiverFromKind(kind: string, init?: RTCRtpTransceiverInit) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      const transceiver = this.connection.addTransceiver(kind, init);\n      this.emit(\"transceiver\", transceiver);\n      this.needsNegotiation();\n      return transceiver;\n    }\n    this.internalSignal({\n      type: \"transceiverRequest\",\n      transceiverRequest: {\n        kind,\n        init,\n      },\n    });\n    return null;\n  }\n\n  addTrack(track: MediaStreamTrack) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    const sender = this.connection.addTrack(track);\n    this.needsNegotiation();\n    return sender;\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    this.connection.removeTrack(sender);\n    this.needsNegotiation();\n    return this;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private internalSignal(message: any) {\n    this.emit(\"signal\", message);\n    return this;\n  }\n\n  private runningNegotiation = false;\n  private async needsNegotiation() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    if (this.initiator) {\n      if (!this.runningNegotiation) {\n        try {\n          this.runningNegotiation = true;\n          await asap();\n          await this.negotiate();\n        } finally {\n          this.runningNegotiation = false;\n        }\n      }\n    }\n    return this;\n  }\n\n  private async negotiate() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    if (this.initiator) {\n      await waitMS(0);\n      await this.createOffer();\n    } else {\n      this.internalSignal({ type: \"renegotiate\", renegotiate: true });\n    }\n    return this;\n  }\n\n  private async createOffer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const offer = await this.connection.createOffer(this.offerConfig);\n    if (!this.trickle) {\n      offer.sdp = filterTrickle(offer.sdp);\n    }\n    offer.sdp = this.sdpTransform(offer.sdp);\n    await this.connection.setLocalDescription(offer);\n    this.internalSignal({ type: offer.type, sdp: offer.sdp });\n    return this;\n  }\n\n  private async createAnswer() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n\n    const answer = await this.connection.createAnswer(this.answerConfig);\n    if (!this.trickle) {\n      answer.sdp = filterTrickle(answer.sdp);\n    }\n    answer.sdp = this.sdpTransform(answer.sdp);\n    await this.connection.setLocalDescription(answer);\n    this.internalSignal({ type: answer.type, sdp: answer.sdp });\n    return this;\n  }\n\n  private createPeer() {\n    this.internalClose(false);\n\n    this.connection = new this.webrtc.RTCPeerConnection(this.config);\n    this.connection.addEventListener(\n      \"connectionstatechange\",\n      this.onConnectionStateChange.bind(this)\n    );\n    this.connection.addEventListener(\n      \"icecandidate\",\n      this.onICECandidate.bind(this)\n    );\n    this.connection.addEventListener(\"track\", this.onTrackRemote.bind(this));\n\n    if (this.initiator) {\n      const channel = this.connection.createDataChannel(\n        this.channelName,\n        this.channelConfig\n      );\n      channel.addEventListener(\"open\", this.onDataChannelOpen.bind(this));\n      channel.addEventListener(\"message\", this.onDataChannelMessage.bind(this));\n      channel.addEventListener(\"error\", this.onDataChannelError.bind(this));\n      this.channel = channel;\n    } else {\n      this.connection.addEventListener(\n        \"datachannel\",\n        this.onDataChannel.bind(this)\n      );\n    }\n    return this;\n  }\n\n  private internalClose(triggerCallbacks = true) {\n    if (this.channel) {\n      this.channel.close();\n      this.channel = undefined;\n    }\n\n    if (this.connection) {\n      this.connection.close();\n      this.connection = undefined;\n    }\n\n    if (triggerCallbacks) {\n      this.emit(\"close\");\n    }\n    return this;\n  }\n\n  private onConnectionStateChange() {\n    if (!this.connection) return;\n\n    switch (this.connection.connectionState) {\n      case \"connected\":\n        break;\n      case \"failed\":\n      case \"disconnected\":\n      case \"closed\":\n        this.internalClose(true);\n        break;\n    }\n  }\n\n  private onICECandidate(event: RTCPeerConnectionIceEvent) {\n    if (event.candidate) {\n      this.internalSignal({\n        type: \"candidate\",\n        candidate: event.candidate,\n      });\n    }\n  }\n\n  private onTrackRemote(event: RTCTrackEvent) {\n    this.emit(\"track\", event);\n  }\n\n  private onDataChannel(event: RTCDataChannelEvent) {\n    const channel = event.channel;\n    this.channel = channel;\n    this.channel.onopen = this.onDataChannelOpen.bind(this);\n    this.channel.onmessage = this.onDataChannelMessage.bind(this);\n    this.channel.onerror = this.onDataChannelError.bind(this);\n  }\n\n  private onDataChannelOpen() {\n    console.debug(`${this.id}: data channel open`);\n    this.emit(\"connect\");\n  }\n\n  private onDataChannelMessage(\n    event: MessageEvent<string | Blob | ArrayBuffer | Uint8Array>\n  ) {\n    this.emit(\"data\", event.data);\n  }\n\n  private onDataChannelError(event: Event) {\n    this.emit(\"error\", new Error(\"DataChannel error\", { cause: event }));\n  }\n}\n\nfunction filterTrickle(sdp?: string) {\n  return sdp?.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction sdpTransform(sdp?: string) {\n  return sdp;\n}\nfunction asap() {\n  return new Promise<void>((resolve) => resolve());\n}\nfunction waitMS(ms: number) {\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction write(\n  channel: RTCDataChannel,\n  chunk: string | Blob | ArrayBuffer | ArrayBufferView,\n  maxChannelMessageSize: number\n) {\n  if (typeof chunk === \"string\") {\n    if (chunk.length < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.length) {\n        const length = Math.min(maxChannelMessageSize, chunk.length - offset);\n        channel.send(chunk.substring(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else if (chunk instanceof Blob) {\n    if (chunk.size < maxChannelMessageSize) {\n      channel.send(chunk);\n    } else {\n      let offset = 0;\n      while (offset < chunk.size) {\n        const length = Math.min(maxChannelMessageSize, chunk.size - offset);\n        channel.send(chunk.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  } else {\n    let buffer: ArrayBuffer;\n    if (chunk instanceof ArrayBuffer) {\n      buffer = chunk;\n    } else {\n      buffer = chunk.buffer;\n    }\n    if (buffer.byteLength < maxChannelMessageSize) {\n      channel.send(buffer);\n    } else {\n      let offset = 0;\n      while (offset < buffer.byteLength) {\n        const length = Math.min(\n          maxChannelMessageSize,\n          buffer.byteLength - offset\n        );\n        channel.send(buffer.slice(offset, offset + length));\n        offset += length;\n      }\n    }\n  }\n}\n\nexport function writableStreamFromChannel(\n  channel: RTCDataChannel,\n  maxChannelMessageSize: number\n) {\n  return new WritableStream({\n    write(chunk: string | Blob | ArrayBuffer | ArrayBufferView) {\n      write(channel, chunk, maxChannelMessageSize);\n    },\n  });\n}\n\nexport function readableStreamFromChannel(channel: RTCDataChannel) {\n  let closed = false;\n  let closedController = false;\n  const queue: Array<string | Blob | ArrayBuffer> = [];\n  const pullQueue: Array<\n    [\n      resolve: (data: string | Blob | ArrayBuffer) => void,\n      reject: (error?: Error) => void\n    ]\n  > = [];\n  function pull() {\n    return new Promise<string | Blob | ArrayBuffer>((resolve, reject) =>\n      pullQueue.push([resolve, reject])\n    );\n  }\n  function onMessage(event: MessageEvent<string | Blob | ArrayBuffer>) {\n    if (pullQueue.length) {\n      // biome-ignore lint/style/noNonNullAssertion: checked above\n      const [resolve, _reject] = pullQueue.shift()!;\n      resolve(event.data);\n    } else {\n      queue.push(event.data);\n    }\n  }\n  channel.addEventListener(\"message\", onMessage);\n  const onClose = () => {\n    if (closed) {\n      return;\n    }\n    channel.removeEventListener(\"message\", onMessage);\n    channel.removeEventListener(\"close\", onClose);\n    closed = true;\n    for (const [_resolve, reject] of pullQueue) {\n      reject(new Error(\"Stream closed\"));\n    }\n    pullQueue.length = 0;\n    queue.length = 0;\n  };\n  channel.addEventListener(\"close\", onClose);\n  return new ReadableStream<string | Blob | ArrayBuffer>({\n    async pull(controller) {\n      if (closed) {\n        if (!closedController) {\n          closedController = true;\n          controller.close();\n        }\n        return;\n      }\n      if (queue.length) {\n        controller.enqueue(queue.shift());\n      } else {\n        controller.enqueue(await pull());\n      }\n    },\n    cancel: onClose,\n  });\n}\n"],"names":["DEFAULT_WEBRTC","RTCPeerConnection","RTCSessionDescription","RTCIceCandidate","Peer","EventEmitter","constructor","options","super","this","initiator","maxChannelMessageSize","trickle","sdpTransform","config","iceServers","pendingCandidates","webrtc","runningNegotiation","id","uuidv4","channelName","channelConfig","offerConfig","answerConfig","getId","getConnection","connection","getChannel","channel","isReady","readyState","isClosed","connectionState","isInitiator","init","createPeer","needsNegotiation","close","internalClose","send","chunk","Error","write","writableStream","writableStreamFromChannel","readableStream","readableStreamFromChannel","signal","message","console","debug","type","transceiverRequest","addTransceiverFromKind","kind","candidateJSON","candidate","remoteDescription","push","addIceCandidate","sdp","sessionDescription","setRemoteDescription","length","_b","_a","createAnswer","waitOnce","event","Promise","resolve","once","args","transceiver","addTransceiver","emit","internalSignal","addTrack","track","sender","removeTrack","negotiate","ms","setTimeout","createOffer","renegotiate","offer","filterTrickle","setLocalDescription","answer","addEventListener","onConnectionStateChange","bind","onICECandidate","onTrackRemote","createDataChannel","onDataChannelOpen","onDataChannelMessage","onDataChannelError","onDataChannel","triggerCallbacks","undefined","onopen","onmessage","onerror","data","cause","replace","offset","Math","min","substring","Blob","size","slice","buffer","ArrayBuffer","byteLength","WritableStream","closed","closedController","queue","pullQueue","onMessage","_reject","shift","onClose","removeEventListener","_resolve","reject","ReadableStream","pull","controller","enqueue","cancel"],"mappings":"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"}